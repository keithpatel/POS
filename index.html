<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üì± UPC Scanner POS Check</title>
    <!-- PDF.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';
    </script>
    <!-- HTML5-QRCode library -->
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        h1, h2 {
            color: #007bff;
        }

        h2 {
            margin-top: 30px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        input[type="file"], input[type="text"] {
            display: block;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: calc(100% - 18px); /* Account for padding and border */
            box-sizing: border-box; /* Ensures padding and border are included in the element's total width and height */
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            margin-right: 5px;
            margin-bottom: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #darkModeToggle {
            background-color: #6c757d;
        }
        #darkModeToggle:hover {
            background-color: #5a6268;
        }


        #pdfStatus, #itemResult {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
        }

        #itemResult.found {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        #itemResult.not-found {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        #resultLogTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.9em;
        }

        #resultLogTable th, #resultLogTable td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        #resultLogTable th {
            background-color: #f0f0f0;
        }

        .hidden {
            display: none !important;
        }

        #qr-reader {
            border: 1px solid #ccc;
            margin-bottom: 10px;
        }
        #qr-reader video { /* Important for responsive video */
            width: 100% !important;
            height: auto !important;
        }
        #scanInstruction {
            text-align: center;
            font-style: italic;
            color: #555;
        }


        /* Dark Mode */
        body.dark-mode {
            background-color: #333;
            color: #f0f0f0;
        }

        body.dark-mode .container {
            background-color: #444;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        body.dark-mode h1, body.dark-mode h2 {
            color: #58a6ff;
        }
        body.dark-mode header, body.dark-mode h2 {
            border-bottom-color: #555;
        }

        body.dark-mode input[type="file"], body.dark-mode input[type="text"] {
            background-color: #555;
            color: #f0f0f0;
            border-color: #666;
        }

        body.dark-mode button {
            background-color: #0056b3; /* A bit darker blue for buttons */
        }
        body.dark-mode button:hover {
            background-color: #003d80;
        }
        body.dark-mode button:disabled {
            background-color: #666;
        }
        body.dark-mode #darkModeToggle {
            background-color: #555;
        }
        body.dark-mode #darkModeToggle:hover {
            background-color: #444;
        }


        body.dark-mode #itemResult.found {
            background-color: #1a3a24;
            color: #c3e6cb;
            border-color: #2a5734;
        }

        body.dark-mode #itemResult.not-found {
            background-color: #4a1c20;
            color: #f5c6cb;
            border-color: #622529;
        }

        body.dark-mode #resultLogTable th, body.dark-mode #resultLogTable td {
            border-color: #555;
        }
        body.dark-mode #resultLogTable th {
            background-color: #3a3a3a;
        }
        body.dark-mode #scanInstruction {
            color: #bbb;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üì± UPC Scanner POS Check</h1>
            <button id="darkModeToggle">üåô/‚òÄÔ∏è</button>
        </header>

        <section id="uploadSection">
            <h2>1. Upload POS List (PDF)</h2>
            <p>Upload your POS product list. This will be stored locally in your browser if space allows.</p>
            <input type="file" id="pdfFile" accept=".pdf">
            <button id="processPdfButton">Process PDF</button>
            <p id="pdfStatus"></p>
        </section>

        <section id="scannerSection" class="hidden">
            <h2>2. Scan UPC via Camera</h2>
            <div id="qr-reader" style="width:100%; max-width: 500px;"></div>
            <div id="scannerControls">
                <button id="startScanButton">Start Camera Scan</button>
                <button id="stopScanButton" disabled>Stop Camera Scan</button>
            </div>
            <p id="scanInstruction" class="hidden">Point camera at barcode...</p>
        </section>

        <section id="manualEntrySection" class="hidden">
            <h2>3. Manual UPC Entry</h2>
            <input type="text" id="manualUpcInput" placeholder="Enter UPC">
            <button id="manualSearchButton">Search UPC</button>
        </section>

        <section id="resultSection">
            <h2>Scan/Search Result</h2>
            <div id="itemResult">---</div>
        </section>

        <section id="logSection">
            <h2>Result Log</h2>
            <table id="resultLogTable">
                <thead>
                    <tr>
                        <th>Timestamp</th>
                        <th>UPC</th>
                        <th>Status</th>
                        <th>Product Name</th>
                        <th>Price</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Log entries will be added here -->
                </tbody>
            </table>
            <button id="exportLogButton">Export Log (CSV)</button>
        </section>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const pdfFileInput = document.getElementById('pdfFile');
            const processPdfButton = document.getElementById('processPdfButton');
            const pdfStatus = document.getElementById('pdfStatus');

            const scannerSection = document.getElementById('scannerSection');
            const startScanButton = document.getElementById('startScanButton');
            const stopScanButton = document.getElementById('stopScanButton');
            const scanInstruction = document.getElementById('scanInstruction');

            const manualEntrySection = document.getElementById('manualEntrySection');
            const manualUpcInput = document.getElementById('manualUpcInput');
            const manualSearchButton = document.getElementById('manualSearchButton');

            const itemResultDiv = document.getElementById('itemResult');
            const resultLogTableBody = document.getElementById('resultLogTable').getElementsByTagName('tbody')[0];
            const exportLogButton = document.getElementById('exportLogButton');
            const darkModeToggle = document.getElementById('darkModeToggle');

            let posData = []; 
            let scanLog = [];
            let html5QrCode = null;

            processPdfButton.addEventListener('click', () => { 
                const file = pdfFileInput.files[0];
                if (!file) {
                    pdfStatus.textContent = 'Please select a PDF file.';
                    pdfStatus.style.color = 'red';
                    return;
                }

                pdfStatus.textContent = 'Processing PDF... Please wait.';
                pdfStatus.style.color = 'orange';
                console.log("PDF processing initiated for file:", file.name);

                const fileReader = new FileReader();

                fileReader.onload = async function() { 
                    console.log("FileReader onload triggered.");
                    try {
                        const typedarray = new Uint8Array(this.result);
                        console.log("PDF data as Uint8Array created, length:", typedarray.length);

                        if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                            console.error("CRITICAL: PDF.js worker source not set!");
                            pdfStatus.textContent = 'Error: PDF.js worker not configured. Cannot process PDF.';
                            pdfStatus.style.color = 'red';
                            return;
                        }

                        const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
                        console.log("PDF document loaded, number of pages:", pdf.numPages);
                        let fullText = '';
                        let pageProcessedSuccessfully = false;

                        for (let i = 1; i <= pdf.numPages; i++) {
                            console.log(`Attempting to process page ${i}...`);
                            try {
                                const page = await pdf.getPage(i);
                                const textContent = await page.getTextContent();
                                textContent.items.forEach(item => {
                                    fullText += item.str + (item.hasEOL ? '\n' : ' ');
                                });
                                fullText += '\n'; 
                                console.log(`Page ${i} processed successfully.`);
                                pageProcessedSuccessfully = true;
                            } catch (pageError) {
                                console.error(`Error processing page ${i}:`, pageError);
                                pdfStatus.textContent = `Error on page ${i}: ${pageError.message}. Trying to continue...`;
                                pdfStatus.style.color = 'orange'; 
                            }
                        }
                        
                        console.log("All pages attempted. Full text length:", fullText.length);
                        if (fullText.trim().length === 0 && pdf.numPages > 0 && !pageProcessedSuccessfully) {
                             console.warn("PDF processing resulted in empty text, and no page was processed successfully. The PDF might be image-based or have non-extractable text.");
                             pdfStatus.textContent = 'Warning: Could not extract text from PDF. It might be an image-based PDF or protected.';
                             pdfStatus.style.color = 'orange';
                        }
                        parsePosData(fullText);

                    } catch (error) {
                        console.error("Error in PDF processing pipeline (fileReader.onload):", error);
                        pdfStatus.textContent = `Error processing PDF: ${error.message || 'Unknown PDF processing error'}`;
                        pdfStatus.style.color = 'red';
                        if (error.name === 'MissingPDFException' || error.name === 'InvalidPDFException') {
                            pdfStatus.textContent = `Error: Invalid or corrupted PDF file. (${error.message})`;
                        } else if (error.message && error.message.includes("network error")) {
                             pdfStatus.textContent = `Network error during PDF processing. Check internet connection or PDF.js worker path.`;
                        }
                    }
                };

                fileReader.onerror = function() {
                    console.error("FileReader error occurred (e.g., could not read file).");
                    pdfStatus.textContent = 'Error reading the selected PDF file.';
                    pdfStatus.style.color = 'red';
                };
                
                try {
                    console.log("Calling fileReader.readAsArrayBuffer...");
                    fileReader.readAsArrayBuffer(file);
                } catch (e) {
                    console.error("Error calling readAsArrayBuffer:", e);
                    pdfStatus.textContent = `Error initiating file read: ${e.message}`;
                    pdfStatus.style.color = 'red';
                }
            });

            function parsePosData(text) {
                console.log("parsePosData called. Text preview (first 500 chars):", text.substring(0, 500));
                posData = []; // Reset posData
                const lines = text.split('\n');
                // Regex to capture: UPC (digits), Product Name (anything, non-greedy), Price (digits.digits)
                const lineRegex = /^(\d+)\s+(.+?)\s+([\d.]+)\s*$/;
                // Simpler regex for UPC Name (no price)
                const lineRegexNoPrice = /^(\d+)\s+(.+?)\s*$/;

                let parsedCount = 0;
                lines.forEach((line, index) => {
                    const trimmedLine = line.trim();
                    // Skip empty or common header lines more broadly
                    if (!trimmedLine || 
                        trimmedLine.toLowerCase().startsWith('upc') || 
                        trimmedLine.toLowerCase().startsWith('product name') || 
                        trimmedLine.toLowerCase().startsWith('price') ||
                        trimmedLine.toLowerCase().startsWith('item name') // Add other header variants if needed
                       ) {
                        return; 
                    }

                    let match = trimmedLine.match(lineRegex);
                    if (match) {
                        posData.push({
                            upc: match[1].trim(), // Ensure UPC from regex is trimmed (though (\d+) shouldn't have spaces)
                            name: match[2].trim(),
                            price: parseFloat(match[3])
                        });
                        parsedCount++;
                    } else {
                        match = trimmedLine.match(lineRegexNoPrice);
                        if (match) {
                            posData.push({
                                upc: match[1].trim(), // Ensure UPC from regex is trimmed
                                name: match[2].trim(),
                                price: null
                            });
                            parsedCount++;
                        } else {
                            // Fallback parsing attempt
                            const parts = trimmedLine.split(/\s\s+/); // Split by 2 or more spaces
                            if (parts.length >= 2 && /^\d+$/.test(parts[0].trim())) { // Check first part is numeric
                                let price = null;
                                let name = parts.slice(1).join(' ').trim();
                                // Check if the last part of the remaining looks like a price
                                const potentialPricePart = parts[parts.length - 1];
                                if (parts.length >= 3 && /^\d+(\.\d+)?$/.test(potentialPricePart)) {
                                    price = parseFloat(potentialPricePart);
                                    name = parts.slice(1, -1).join(' ').trim(); // Name is between UPC and Price
                                }
                                posData.push({ upc: parts[0].trim(), name: name, price: price });
                                parsedCount++;
                            } else if (trimmedLine.length > 5) { // Avoid logging for very short, likely irrelevant lines
                                console.warn(`Could not parse line ${index + 1} with regexes or fallback: "${trimmedLine}"`);
                            }
                        }
                    }
                });

                console.log("parsePosData finished. Total items parsed:", parsedCount, "Total items in posData:", posData.length);
                
                // --- DEBUG LOGGING for specific UPCs ---
                if (posData.length > 0) {
                    console.log("First 10 parsed POS Data items (for debugging):");
                    console.log(JSON.stringify(posData.slice(0, 10).map(item => ({ upc: item.upc, name: item.name})), null, 2));

                    const debugUPCs = ["3", "17"]; // UPCs you are testing
                    debugUPCs.forEach(testUpc => {
                        const foundDebugItem = posData.find(item => item.upc === testUpc || String(parseInt(item.upc, 10)) === testUpc);
                        if (foundDebugItem) {
                            console.log(`DEBUG: Item for UPC "${testUpc}" FOUND in posData after parsing. Stored as: UPC="${foundDebugItem.upc}", Name="${foundDebugItem.name}"`);
                        } else {
                            console.log(`DEBUG: Item for UPC "${testUpc}" NOT FOUND in posData after parsing. Check PDF content and parsing logic for this UPC.`);
                        }
                    });
                }
                // --- END DEBUG LOGGING ---


                if (posData.length > 0) {
                    try {
                        localStorage.setItem('posData', JSON.stringify(posData));
                        pdfStatus.textContent = `Successfully processed ${posData.length} items from PDF. Data saved for next session.`;
                        pdfStatus.style.color = 'green';
                    } catch (e) {
                        if (e.name === 'QuotaExceededError' || (e.message && e.message.toLowerCase().includes('quota'))) {
                            console.warn("localStorage quota exceeded. Data will be available for this session only.");
                            pdfStatus.textContent = `Processed ${posData.length} items. Data is too large to save for next session (localStorage quota exceeded). Tool will work for this session only.`;
                            pdfStatus.style.color = 'orange';
                        } else {
                            console.error("Error saving to localStorage:", e);
                            pdfStatus.textContent = `Processed ${posData.length} items. Could not save data for next session: ${e.message}. Tool will work for this session only.`;
                            pdfStatus.style.color = 'orange';
                        }
                    }
                    enableScanningAndManualEntry();
                } else {
                    if (text.trim().length === 0 && lines.length <=1 ) {
                         pdfStatus.textContent = 'No text could be extracted from the PDF. It might be image-based or protected. Please check the PDF content.';
                    } else {
                         pdfStatus.textContent = 'No valid POS data found matching the expected formats (e.g., "UPC ProductName Price" or "UPC ProductName"). Check PDF content & console for warnings on unparsed lines.';
                    }
                    pdfStatus.style.color = 'red';
                    console.log("POS Data after parsing is empty. Ensure your PDF has text in a parsable format.");
                }
            }


            function enableScanningAndManualEntry() {
                scannerSection.classList.remove('hidden');
                manualEntrySection.classList.remove('hidden');
            }

            function onScanSuccess(decodedText, decodedResult) {
                console.log(`Code matched = ${decodedText}`, decodedResult);
                checkUpc(decodedText);
            }

            function onScanFailure(error) {
                // console.warn(`Code scan error = ${error}`);
            }

            startScanButton.addEventListener('click', () => {
                if (!html5QrCode) {
                    try {
                        html5QrCode = new Html5Qrcode("qr-reader");
                    } catch (e) {
                        console.error("Error initializing Html5Qrcode:", e);
                        itemResultDiv.textContent = `Error initializing scanner: ${e.message}. Try reloading.`;
                        itemResultDiv.className = 'not-found';
                        return;
                    }
                }
                
                const qrboxFunction = (viewfinderWidth, viewfinderHeight) => {
                    let minEdgePercentage = 0.7; 
                    let minEdgeSize = Math.min(viewfinderWidth, viewfinderHeight);
                    let qrboxSize = Math.floor(minEdgeSize * minEdgePercentage);
                    return { width: qrboxSize, height: qrboxSize };
                };

                const config = { fps: 10, qrbox: qrboxFunction, aspectRatio: 1.0 }; 
                
                scanInstruction.classList.remove('hidden');
                startScanButton.disabled = true;
                stopScanButton.disabled = false;

                html5QrCode.start({ facingMode: "environment" }, config, onScanSuccess, onScanFailure)
                    .catch((err) => {
                        console.warn("Environment camera failed or not found, trying any available camera:", err);
                        html5QrCode.start(undefined, config, onScanSuccess, onScanFailure)
                            .catch((err2) => {
                                itemResultDiv.textContent = `Camera access error: ${err2.message || err2}. Ensure permissions are granted.`;
                                itemResultDiv.className = 'not-found';
                                console.error("Failed to start scanner:", err2);
                                scanInstruction.classList.add('hidden');
                                startScanButton.disabled = false;
                                stopScanButton.disabled = true;
                            });
                    });
            });

            stopScanButton.addEventListener('click', stopScanner);

            function stopScanner() {
                if (html5QrCode && html5QrCode.isScanning) {
                    html5QrCode.stop()
                        .then(() => {
                            scanInstruction.classList.add('hidden');
                            startScanButton.disabled = false;
                            stopScanButton.disabled = true;
                            console.log("QR Code scanning stopped.");
                        })
                        .catch((err) => {
                            console.error("Failed to stop QR Code scanning.", err);
                            scanInstruction.classList.add('hidden');
                            startScanButton.disabled = false;
                            stopScanButton.disabled = true;
                        });
                } else {
                    scanInstruction.classList.add('hidden');
                    startScanButton.disabled = false;
                    stopScanButton.disabled = true;
                }
            }

            manualSearchButton.addEventListener('click', () => {
                const upc = manualUpcInput.value.trim();
                if (upc) {
                    checkUpc(upc);
                } else {
                    itemResultDiv.textContent = 'Please enter a UPC.';
                    itemResultDiv.className = 'not-found';
                }
            });
            manualUpcInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    manualSearchButton.click();
                }
            });

            function checkUpc(scannedUpcValue) {
                // 1. Trim whitespace from the scanned UPC
                const upcToFind = String(scannedUpcValue).trim();
                
                // 2. Normalize the scanned UPC (remove leading zeros by converting to number then back to string)
                //    Only do this if it looks like a number. If it contains non-digits, keep as is.
                let normalizedScannedUpc = upcToFind;
                if (/^\d+$/.test(upcToFind)) { // Check if it's all digits
                    normalizedScannedUpc = String(parseInt(upcToFind, 10));
                }

                console.log(`Checking UPC: Original scanned: "${scannedUpcValue}", Trimmed: "${upcToFind}", Normalized for comparison: "${normalizedScannedUpc}" (Type: ${typeof normalizedScannedUpc})`);

                if (posData.length === 0) {
                    itemResultDiv.textContent = 'POS data not loaded. Please upload PDF first.';
                    itemResultDiv.className = 'not-found';
                    return;
                }

                // For debugging, log a few stored UPCs and their normalized versions
                if (posData.length > 0 && posData.length < 20) { // Log only for small lists to avoid console spam
                    console.log("Sample stored UPCs (and their normalized versions for comparison):");
                    posData.slice(0,5).forEach(item => {
                        let normalizedStored = String(item.upc).trim();
                        if (/^\d+$/.test(normalizedStored)) {
                            normalizedStored = String(parseInt(normalizedStored,10));
                        }
                        console.log(`  Stored: "${item.upc}", Normalized: "${normalizedStored}"`);
                    });
                }

                const foundItem = posData.find(item => {
                    // Ensure item.upc is a string and trim it
                    const storedUpc = String(item.upc || "").trim(); 

                    // Normalize the stored UPC (remove leading zeros if it's all digits)
                    let normalizedStoredUpc = storedUpc;
                    if (/^\d+$/.test(storedUpc)) { // Check if it's all digits
                        normalizedStoredUpc = String(parseInt(storedUpc, 10));
                    }
                    
                    return normalizedStoredUpc === normalizedScannedUpc;
                });

                let logEntry;

                if (foundItem) {
                    itemResultDiv.innerHTML = `‚úÖ Item Found: <strong>${foundItem.name}</strong> (Price: ${foundItem.price !== null && foundItem.price !== undefined ? '$' + parseFloat(foundItem.price).toFixed(2) : 'N/A'})`;
                    itemResultDiv.className = 'found';
                    logEntry = {
                        timestamp: new Date(),
                        upc: scannedUpcValue, // Log the original scanned UPC
                        status: 'Found',
                        name: foundItem.name,
                        price: foundItem.price
                    };
                } else {
                    itemResultDiv.textContent = `‚ùå UPC "${scannedUpcValue}" not in POS list.`; // Show original scanned UPC
                    itemResultDiv.className = 'not-found';
                    logEntry = {
                        timestamp: new Date(),
                        upc: scannedUpcValue, // Log the original scanned UPC
                        status: 'Not Found',
                        name: '-',
                        price: null
                    };
                }
                addLogEntry(logEntry);
                manualUpcInput.value = ''; 
                manualUpcInput.focus(); 
            }

            function addLogEntry(entry) {
                scanLog.unshift(entry); 
                updateLogTable();
            }

            function updateLogTable() {
                resultLogTableBody.innerHTML = ''; 
                scanLog.forEach(entry => {
                    const row = resultLogTableBody.insertRow();
                    row.insertCell().textContent = entry.timestamp.toLocaleString();
                    row.insertCell().textContent = entry.upc;
                    row.insertCell().textContent = entry.status;
                    const nameCell = row.insertCell();
                    nameCell.textContent = entry.name;
                    if(entry.status === 'Found') nameCell.style.fontWeight = 'bold';

                    row.insertCell().textContent = entry.price !== null && entry.price !== undefined ? `$${parseFloat(entry.price).toFixed(2)}` : '-';
                });
            }

            exportLogButton.addEventListener('click', () => {
                if (scanLog.length === 0) {
                    alert('Log is empty.');
                    return;
                }
                let csvContent = "data:text/csv;charset=utf-8,";
                csvContent += "Timestamp,UPC,Status,Product Name,Price\n"; 
                scanLog.forEach(entry => {
                    const nameForCsv = entry.name ? `"${entry.name.replace(/"/g, '""')}"` : '""'; 
                    const priceForCsv = entry.price !== null && entry.price !== undefined ? parseFloat(entry.price).toFixed(2) : '';
                    const row = [
                        entry.timestamp.toISOString(), 
                        entry.upc,
                        entry.status,
                        nameForCsv,
                        priceForCsv
                    ].join(",");
                    csvContent += row + "\n";
                });

                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                link.setAttribute("download", `scan_log_${timestamp}.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });

            darkModeToggle.addEventListener('click', () => {
                document.body.classList.toggle('dark-mode');
                if (document.body.classList.contains('dark-mode')) {
                    localStorage.setItem('darkMode', 'enabled');
                } else {
                    localStorage.setItem('darkMode', 'disabled');
                }
            });

            function loadInitialState() {
                const storedPosData = localStorage.getItem('posData');
                if (storedPosData) {
                    try {
                        posData = JSON.parse(storedPosData);
                        pdfStatus.textContent = `Loaded ${posData.length} items from local storage.`;
                        pdfStatus.style.color = 'blue';
                        enableScanningAndManualEntry();
                    } catch (e) {
                        console.error("Error parsing stored POS data:", e);
                        localStorage.removeItem('posData'); 
                        pdfStatus.textContent = 'Error loading stored data. Please re-upload PDF.';
                        pdfStatus.style.color = 'red';
                    }
                } else {
                    pdfStatus.textContent = 'Upload your POS PDF to begin.';
                }

                if (localStorage.getItem('darkMode') === 'enabled') {
                    document.body.classList.add('dark-mode');
                }
            }

            loadInitialState();
        });
    </script>
</body>
</html>
